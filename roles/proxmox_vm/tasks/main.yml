---
- name: Validate required input
  ansible.builtin.assert:
    that:
      - vm_name | length > 0
      - proxmox_api_host | length > 0
      - proxmox_api_user | length > 0
      - proxmox_api_token_id | length > 0
      - proxmox_api_token_secret | length > 0
      - proxmox_node | length > 0
      - proxmox_snippets_storage | length > 0
      - proxmox_template_vmid | string | length > 0
      - disk_size_gb | int > 0
      - cpu_sockets | int > 0
      - cpu_cores | int > 0
      - memory_mb | int > 0
      - network_bridge | length > 0

- name: Normalize ip mode
  ansible.builtin.set_fact:
    vm_ip_mode: "{{ ip_mode | lower | trim }}"

- name: Validate ip mode
  ansible.builtin.assert:
    that:
      - vm_ip_mode in ['dhcp', 'static', 'phpipam']
    fail_msg: "ip_mode must be one of: dhcp, static, phpipam"

- name: Dry-run notice
  ansible.builtin.debug:
    msg: "Running in Ansible check mode (dry-run). Proxmox create/update tasks are skipped by design."
  when: ansible_check_mode

- name: End play early in dry-run mode
  ansible.builtin.meta: end_play
  when: ansible_check_mode

- name: Validate static networking input
  ansible.builtin.assert:
    that:
      - static_ip_cidr | length > 0
      - static_gateway | length > 0
      - static_dns1 | length > 0
      - static_dns2 | length > 0
  when: vm_ip_mode == 'static'

- name: Validate phpIPAM input
  ansible.builtin.assert:
    that:
      - phpipam_url | length > 0
      - phpipam_app_id | length > 0
      - phpipam_username | length > 0
      - phpipam_password | length > 0
  when: vm_ip_mode == 'phpipam'

- name: Resolve phpIPAM vlan id
  ansible.builtin.set_fact:
    resolved_phpipam_vlan_id: "{{ (phpipam_vlan_id | string | trim) if (phpipam_vlan_id | string | trim | length > 0) else (vlan_tag | string) }}"
  when: vm_ip_mode == 'phpipam'

- name: Authenticate against phpIPAM
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/user/"
    method: POST
    body_format: form-urlencoded
    body:
      username: "{{ phpipam_username }}"
      password: "{{ phpipam_password }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_auth_response
  when: vm_ip_mode == 'phpipam'

- name: Fetch phpIPAM subnets
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/subnets/"
    method: GET
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_subnets_response
  when: vm_ip_mode == 'phpipam'

- name: Filter phpIPAM subnets by vlan and optional section
  ansible.builtin.set_fact:
    phpipam_candidate_subnets: >-
      {% set out = [] %}
      {% for subnet in (phpipam_subnets_response.json.data | default([])) %}
      {% set vlan_match = (subnet.vlanId | string) == (resolved_phpipam_vlan_id | string) %}
      {% set section_match = (phpipam_section_id | string | trim | length == 0) or ((subnet.sectionId | string) == (phpipam_section_id | string)) %}
      {% if vlan_match and section_match %}
      {% set _ = out.append(subnet) %}
      {% endif %}
      {% endfor %}
      {{ out }}
  when: vm_ip_mode == 'phpipam'

- name: Validate phpIPAM subnet match
  ansible.builtin.assert:
    that:
      - phpipam_candidate_subnets | length > 0
    fail_msg: "No subnet found in phpIPAM for vlanId={{ resolved_phpipam_vlan_id }}"
  when: vm_ip_mode == 'phpipam'

- name: Pick first matching phpIPAM subnet
  ansible.builtin.set_fact:
    phpipam_selected_subnet: "{{ phpipam_candidate_subnets | first }}"
  when: vm_ip_mode == 'phpipam'

- name: Ask phpIPAM for first free IP
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/addresses/first_free/{{ phpipam_selected_subnet.id }}/"
    method: GET
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_first_free_response
  when: vm_ip_mode == 'phpipam'

- name: Reserve IP in phpIPAM
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/addresses/"
    method: POST
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    body_format: form-urlencoded
    body:
      subnetId: "{{ phpipam_selected_subnet.id }}"
      ip: "{{ phpipam_first_free_response.json.data }}"
      hostname: "{{ vm_name }}"
      description: "Created by Semaphore/Ansible"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: [200, 201]
  when: vm_ip_mode == 'phpipam'

- name: Build static network config from phpIPAM data
  ansible.builtin.set_fact:
    static_ip_cidr: "{{ phpipam_first_free_response.json.data }}/{{ phpipam_selected_subnet.mask }}"
    static_gateway: "{{ phpipam_selected_subnet.gateway | default('') }}"
    static_dns1: "{{ phpipam_dns1 }}"
    static_dns2: "{{ phpipam_dns2 }}"
    vm_ip_mode: "static"
  when: vm_ip_mode == 'phpipam'

- name: Validate phpIPAM derived network values
  ansible.builtin.assert:
    that:
      - static_ip_cidr | length > 0
      - static_gateway | length > 0
      - static_dns1 | length > 0
      - static_dns2 | length > 0
    fail_msg: "phpIPAM mode requires gateway and dns values (set phpipam_dns1/phpipam_dns2 and ensure subnet has gateway)."
  when: ip_mode | lower | trim == 'phpipam'

- name: Build Proxmox API auth header
  ansible.builtin.set_fact:
    proxmox_auth_header: "PVEAPIToken={{ proxmox_api_user }}!{{ proxmox_api_token_id }}={{ proxmox_api_token_secret }}"

- name: Resolve VM ID from user input
  ansible.builtin.set_fact:
    resolved_vm_id: "{{ vm_id | string | trim }}"

- name: Ask Proxmox for next free VM ID
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/cluster/nextid"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_nextid_response
  when: resolved_vm_id == 'auto'

- name: Finalize VM ID
  ansible.builtin.set_fact:
    vm_vmid: >-
      {{
        (
          ((proxmox_nextid_response | default({})).get('json', {})).get('data', resolved_vm_id)
          if resolved_vm_id == 'auto'
          else resolved_vm_id
        ) | int
      }}

- name: Build cloud-init IP config
  ansible.builtin.set_fact:
    vm_ipconfig0: "{{ 'ip=dhcp' if vm_ip_mode == 'dhcp' else 'ip=' + static_ip_cidr + ',gw=' + static_gateway }}"

- name: Build cloud-init login config
  ansible.builtin.set_fact:
    vm_effective_ciuser: "{{ 'root' if root_password | length > 0 else cloudinit_ciuser }}"
    vm_optional_password_payload: "{{ {'cipassword': root_password} if root_password | length > 0 else {} }}"

- name: Build cloud-init user-data snippet content
  ansible.builtin.set_fact:
    vm_snippets_storage_in_use: "{{ proxmox_snippets_storage }}"
    vm_cloudinit_snippet_name: "vm-{{ vm_vmid }}-{{ lookup('pipe', 'date +%s') }}-user-data.yaml"
    vm_cloudinit_user_data_content: |
      #cloud-config
      package_update: true
      packages:
        - qemu-guest-agent
      runcmd:
        - systemctl enable --now qemu-guest-agent

- name: Write cloud-init user-data snippet to local temp file
  ansible.builtin.copy:
    content: "{{ vm_cloudinit_user_data_content }}"
    dest: "/tmp/{{ vm_cloudinit_snippet_name }}"
    mode: "0600"

- name: Upload cloud-init user-data snippet to Proxmox storage
  block:
    - name: Upload snippet to configured snippets storage
      ansible.builtin.uri:
        url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/storage/{{ proxmox_snippets_storage }}/upload"
        method: POST
        headers:
          Authorization: "{{ proxmox_auth_header }}"
        body_format: form-multipart
        body:
          content: snippets
          filename:
            filename: "/tmp/{{ vm_cloudinit_snippet_name }}"
            mime_type: text/plain
        validate_certs: "{{ proxmox_validate_certs }}"
        return_content: true
        status_code: 200
  rescue:
    - name: Fallback snippet storage to local
      ansible.builtin.set_fact:
        vm_snippets_storage_in_use: "local"

    - name: Upload snippet to local snippets storage fallback
      ansible.builtin.uri:
        url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/storage/local/upload"
        method: POST
        headers:
          Authorization: "{{ proxmox_auth_header }}"
        body_format: form-multipart
        body:
          content: snippets
          filename:
            filename: "/tmp/{{ vm_cloudinit_snippet_name }}"
            mime_type: text/plain
        validate_certs: "{{ proxmox_validate_certs }}"
        return_content: true
        status_code: 200

- name: Remove temporary local cloud-init snippet file
  ansible.builtin.file:
    path: "/tmp/{{ vm_cloudinit_snippet_name }}"
    state: absent

- name: Check if target VM already exists
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 404, 500]
  register: proxmox_existing_vm_config_response
  failed_when: false

- name: Set VM existence flag
  ansible.builtin.set_fact:
    vm_already_exists: "{{ proxmox_existing_vm_config_response.status | int == 200 }}"

- name: Clone Debian 13 template via Proxmox API
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ proxmox_template_vmid }}/clone"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      newid: "{{ vm_vmid }}"
      name: "{{ vm_name }}"
      full: 1
      storage: "{{ vm_storage }}"
      target: "{{ proxmox_node }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  when: not vm_already_exists

- name: Wait until VM config is available after clone
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_ready_response
  until: proxmox_vm_ready_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: not vm_already_exists

- name: Build optional SSH key payload
  ansible.builtin.set_fact:
    vm_optional_sshkeys_payload: "{{ {'sshkeys': cloudinit_ssh_public_keys} if cloudinit_ssh_public_keys | length > 0 else {} }}"

- name: Build common VM config payload
  ansible.builtin.set_fact:
    vm_config_payload_common:
      cpu: "{{ vm_cpu_type }}"
      sockets: "{{ cpu_sockets | int }}"
      cores: "{{ cpu_cores | int }}"
      memory: "{{ memory_mb | int }}"
      onboot: "{{ 1 if vm_onboot else 0 }}"
      agent: "{{ 1 if vm_qemu_agent else 0 }}"
      numa: "{{ 1 if vm_numa else 0 }}"
      hotplug: "{{ vm_hotplug }}"
      ciuser: "{{ vm_effective_ciuser }}"
      cicustom: "user={{ vm_snippets_storage_in_use }}:snippets/{{ vm_cloudinit_snippet_name }}"
      ipconfig0: "{{ vm_ipconfig0 }}"
      net0: "virtio,bridge={{ network_bridge }},tag={{ vlan_tag }},firewall={{ 1 if vm_firewall else 0 }},mtu={{ vm_mtu }}"

- name: Configure VM hardware and cloud-init networking (dhcp)
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_config_dhcp_response
  until: proxmox_config_dhcp_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: vm_ip_mode == 'dhcp'
  failed_when: proxmox_config_dhcp_response.status | int != 200

- name: Configure VM hardware and cloud-init networking (static)
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine({'nameserver': static_dns1 + ' ' + static_dns2}) | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_config_static_response
  until: proxmox_config_static_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: vm_ip_mode == 'static'
  failed_when: proxmox_config_static_response.status | int != 200

- name: Read current VM config
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_config_response

- name: Extract current disk config
  ansible.builtin.set_fact:
    vm_scsi0_config: "{{ proxmox_vm_config_response.json.data.scsi0 | default('') }}"
    vm_current_disk_gb: "{{ ((proxmox_vm_config_response.json.data.scsi0 | default('') | regex_findall('size=(\\d+)G') | first | default('0')) | int) }}"

- name: Validate disk config exists
  ansible.builtin.assert:
    that:
      - vm_scsi0_config | length > 0
    fail_msg: "Could not read scsi0 from VM config. Ensure Debian template disk is on scsi0."

- name: Fail if requested disk is smaller than template disk
  ansible.builtin.assert:
    that:
      - disk_size_gb | int >= vm_current_disk_gb | int
    fail_msg: "Requested disk_size_gb ({{ disk_size_gb }}) is smaller than template disk ({{ vm_current_disk_gb }}G). Proxmox cannot shrink disk via API."

- name: Expand disk when requested size is larger than current size
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/resize"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      disk: scsi0
      size: "+{{ (disk_size_gb | int) - (vm_current_disk_gb | int) }}G"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_resize_response
  until: proxmox_resize_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: disk_size_gb | int > vm_current_disk_gb | int
  failed_when: proxmox_resize_response.status | int != 200

- name: Build scsi0 config with backup disabled
  ansible.builtin.set_fact:
    vm_scsi0_with_backup_disabled: >-
      {{
        vm_scsi0_config | regex_replace('backup=1', 'backup=0')
        if 'backup=' in vm_scsi0_config
        else vm_scsi0_config + ',backup=0'
      }}

- name: Apply backup disabled on scsi0
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      scsi0: "{{ vm_scsi0_with_backup_disabled }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_backup_flag_response
  until: proxmox_backup_flag_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  failed_when: proxmox_backup_flag_response.status | int != 200

- name: Read current VM runtime status
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/status/current"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_status_response

- name: Ensure VM is started
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/status/start"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_start_response
  until: proxmox_start_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: (proxmox_vm_status_response.json.data.status | default('stopped')) != 'running'
  failed_when: proxmox_start_response.status | int != 200

- name: Wait for QEMU guest agent to become ready
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/ping"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_agent_ping_response
  until: proxmox_agent_ping_response.status | int == 200
  retries: "{{ cloudinit_wait_retries }}"
  delay: "{{ cloudinit_wait_delay }}"
  when: wait_for_cloudinit | bool
  failed_when: proxmox_agent_ping_response.status | int != 200

- name: Start cloud-init wait command inside guest
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/exec"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      command:
        - cloud-init
        - status
        - --wait
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_cloudinit_exec_response
  when: wait_for_cloudinit | bool

- name: Poll cloud-init wait command result
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/exec-status?pid={{ proxmox_cloudinit_exec_response.json.data.pid }}"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_cloudinit_exec_status_response
  until:
    - proxmox_cloudinit_exec_status_response.status | int == 200
    - (proxmox_cloudinit_exec_status_response.json.data.exited | default(false))
    - (proxmox_cloudinit_exec_status_response.json.data.exitcode | default(1) | int) == 0
  retries: "{{ cloudinit_wait_retries }}"
  delay: "{{ cloudinit_wait_delay }}"
  when: wait_for_cloudinit | bool
  failed_when: >
    proxmox_cloudinit_exec_status_response.status | int != 200 or
    not (proxmox_cloudinit_exec_status_response.json.data.exited | default(false)) or
    (proxmox_cloudinit_exec_status_response.json.data.exitcode | default(1) | int) != 0

- name: Output summary
  ansible.builtin.debug:
    msg:
      - "VM created: {{ vm_name }} (vmid={{ vm_vmid }})"
      - "Disk: {{ disk_size_gb }}G, CPU: {{ cpu_sockets }} sockets x {{ cpu_cores }} cores, RAM: {{ memory_mb }} MB"
      - "Network: bridge={{ network_bridge }}, vlan={{ vlan_tag }}, mode={{ vm_ip_mode }}"
      - "Cloud-init login user: {{ vm_effective_ciuser }}"
      - "Cloud-init initialization: {{ 'waited until done' if wait_for_cloudinit | bool else 'wait disabled' }}"
      - "Cloud-init snippet storage: {{ vm_snippets_storage_in_use }}"
