---
- name: Validate required input
  ansible.builtin.assert:
    that:
      - vm_name | length > 0
      - proxmox_api_host | length > 0
      - proxmox_api_user | length > 0
      - proxmox_api_token_id | length > 0
      - proxmox_api_token_secret | length > 0
      - proxmox_node | length > 0
      - proxmox_template_vmid | string | length > 0
      - disk_size_gb | int > 0
      - cpu_sockets | int > 0
      - cpu_cores | int > 0
      - memory_mb | int > 0
      - network_bridge | length > 0

- name: Normalize ip mode
  ansible.builtin.set_fact:
    vm_ip_mode: "{{ ip_mode | lower | trim }}"

- name: Validate ip mode
  ansible.builtin.assert:
    that:
      - vm_ip_mode in ['dhcp', 'static', 'phpipam']
    fail_msg: "ip_mode must be one of: dhcp, static, phpipam"

- name: Validate AD join input
  ansible.builtin.assert:
    that:
      - ad_domain_name | length > 0
      - ad_join_user | length > 0
      - ad_join_password | length > 0
    fail_msg: "When join_ad=true you must set ad_domain_name, ad_join_user and ad_join_password."
  when: join_ad | bool

- name: Dry-run notice
  ansible.builtin.debug:
    msg: "Running in Ansible check mode (dry-run). Proxmox create/update tasks are skipped by design."
  when: ansible_check_mode

- name: End play early in dry-run mode
  ansible.builtin.meta: end_play
  when: ansible_check_mode

- name: Validate static networking input
  ansible.builtin.assert:
    that:
      - static_ip_cidr | length > 0
      - static_gateway | length > 0
      - static_dns1 | length > 0
      - static_dns2 | length > 0
  when: vm_ip_mode == 'static'

- name: Validate phpIPAM input
  ansible.builtin.assert:
    that:
      - phpipam_url | length > 0
      - phpipam_app_id | length > 0
      - phpipam_username | length > 0
      - phpipam_password | length > 0
  when: vm_ip_mode == 'phpipam'

- name: Resolve phpIPAM vlan id
  ansible.builtin.set_fact:
    resolved_phpipam_vlan_id: "{{ (phpipam_vlan_id | string | trim) if (phpipam_vlan_id | string | trim | length > 0) else (vlan_tag | string) }}"
  when: vm_ip_mode == 'phpipam'

- name: Authenticate against phpIPAM
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/user/"
    method: POST
    body_format: form-urlencoded
    body:
      username: "{{ phpipam_username }}"
      password: "{{ phpipam_password }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_auth_response
  when: vm_ip_mode == 'phpipam'

- name: Fetch phpIPAM subnets
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/subnets/"
    method: GET
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_subnets_response
  when: vm_ip_mode == 'phpipam'

- name: Filter phpIPAM subnets by vlan and optional section
  ansible.builtin.set_fact:
    phpipam_candidate_subnets: >-
      {% set out = [] %}
      {% for subnet in (phpipam_subnets_response.json.data | default([])) %}
      {% set vlan_match = (subnet.vlanId | string) == (resolved_phpipam_vlan_id | string) %}
      {% set section_match = (phpipam_section_id | string | trim | length == 0) or ((subnet.sectionId | string) == (phpipam_section_id | string)) %}
      {% if vlan_match and section_match %}
      {% set _ = out.append(subnet) %}
      {% endif %}
      {% endfor %}
      {{ out }}
  when: vm_ip_mode == 'phpipam'

- name: Validate phpIPAM subnet match
  ansible.builtin.assert:
    that:
      - phpipam_candidate_subnets | length > 0
    fail_msg: "No subnet found in phpIPAM for vlanId={{ resolved_phpipam_vlan_id }}"
  when: vm_ip_mode == 'phpipam'

- name: Pick first matching phpIPAM subnet
  ansible.builtin.set_fact:
    phpipam_selected_subnet: "{{ phpipam_candidate_subnets | first }}"
  when: vm_ip_mode == 'phpipam'

- name: Ask phpIPAM for first free IP
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/addresses/first_free/{{ phpipam_selected_subnet.id }}/"
    method: GET
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: 200
  register: phpipam_first_free_response
  when: vm_ip_mode == 'phpipam'

- name: Reserve IP in phpIPAM
  ansible.builtin.uri:
    url: "{{ phpipam_url.rstrip('/') }}/api/{{ phpipam_app_id }}/addresses/"
    method: POST
    headers:
      token: "{{ phpipam_auth_response.json.data.token }}"
    body_format: form-urlencoded
    body:
      subnetId: "{{ phpipam_selected_subnet.id }}"
      ip: "{{ phpipam_first_free_response.json.data }}"
      hostname: "{{ vm_name }}"
      description: "Created by Semaphore/Ansible"
    validate_certs: "{{ phpipam_verify_ssl }}"
    return_content: true
    status_code: [200, 201]
  when: vm_ip_mode == 'phpipam'

- name: Build static network config from phpIPAM data
  ansible.builtin.set_fact:
    static_ip_cidr: "{{ phpipam_first_free_response.json.data }}/{{ phpipam_selected_subnet.mask }}"
    static_gateway: "{{ phpipam_selected_subnet.gateway | default('') }}"
    static_dns1: "{{ phpipam_dns1 }}"
    static_dns2: "{{ phpipam_dns2 }}"
    vm_ip_mode: "static"
  when: vm_ip_mode == 'phpipam'

- name: Validate phpIPAM derived network values
  ansible.builtin.assert:
    that:
      - static_ip_cidr | length > 0
      - static_gateway | length > 0
      - static_dns1 | length > 0
      - static_dns2 | length > 0
    fail_msg: "phpIPAM mode requires gateway and dns values (set phpipam_dns1/phpipam_dns2 and ensure subnet has gateway)."
  when: ip_mode | lower | trim == 'phpipam'

- name: Build Proxmox API auth header
  ansible.builtin.set_fact:
    proxmox_auth_header: "PVEAPIToken={{ proxmox_api_user }}!{{ proxmox_api_token_id }}={{ proxmox_api_token_secret }}"

- name: Resolve VM ID from user input
  ansible.builtin.set_fact:
    resolved_vm_id: "{{ vm_id | string | trim }}"

- name: Ask Proxmox for next free VM ID
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/cluster/nextid"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_nextid_response
  when: resolved_vm_id == 'auto'

- name: Finalize VM ID
  ansible.builtin.set_fact:
    vm_vmid: >-
      {{
        (
          ((proxmox_nextid_response | default({})).get('json', {})).get('data', resolved_vm_id)
          if resolved_vm_id == 'auto'
          else resolved_vm_id
        ) | int
      }}

- name: Build cloud-init IP config
  ansible.builtin.set_fact:
    vm_ipconfig0: "{{ 'ip=dhcp' if vm_ip_mode == 'dhcp' else 'ip=' + static_ip_cidr + ',gw=' + static_gateway }}"

- name: Build cloud-init login config
  ansible.builtin.set_fact:
    vm_effective_ciuser: "{{ 'root' if root_password | length > 0 else cloudinit_ciuser }}"
    vm_optional_password_payload: "{{ {'cipassword': root_password} if root_password | length > 0 else {} }}"

- name: Determine cloud-init snippet source
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_source: >-
      {{
        (cloudinit_user_data_snippet | trim)
        if (cloudinit_user_data_snippet | trim | length > 0)
        else ('user=' + proxmox_snippets_storage + ':snippets/' + cloudinit_user_data_snippet_filename)
      }}

- name: Parse cloud-init snippet storage and volume id
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_storage_id: "{{ vm_cloudinit_snippet_source | regex_replace('^user=([^:]+):.*$', '\\1') }}"
    vm_cloudinit_snippet_volid: "{{ vm_cloudinit_snippet_source | regex_replace('^user=', '') }}"
    vm_proxmox_snippets_mount_path: "{{ proxmox_snippets_mount_path if proxmox_snippets_mount_path | length > 0 else ('/mnt/pve/' + proxmox_snippets_storage) }}"
    vm_proxmox_delegate_host: >-
      {{
        proxmox_inventory_host
        if proxmox_inventory_host | length > 0
        else ((groups['proxmox_api'] | default([])) | first | default(proxmox_api_host))
      }}
    vm_cloudinit_user_data_content: |
      #cloud-config
      package_update: true
      packages:
        - qemu-guest-agent
      runcmd:
        - systemctl enable --now qemu-guest-agent
  when: vm_cloudinit_snippet_source | length > 0

- name: Query Proxmox storage content for snippet existence
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/storage/{{ vm_cloudinit_snippet_storage_id }}/content"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 404, 500]
  register: proxmox_snippet_storage_content_response
  failed_when: false
  when: vm_cloudinit_snippet_source | length > 0

- name: Resolve initial snippet existence from Proxmox API
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_exists: >-
      {{
        (proxmox_snippet_storage_content_response.status | default(500) | int == 200)
        and
        (
          (
            proxmox_snippet_storage_content_response.json.data
            | default([])
            | selectattr('volid', 'equalto', vm_cloudinit_snippet_volid)
            | list
            | length
          ) > 0
        )
      }}
  when: vm_cloudinit_snippet_source | length > 0

- name: Create snippet on Proxmox host via inventory fallback when missing
  when:
    - vm_cloudinit_snippet_source | length > 0
    - enable_inventory_snippet_fallback | bool
    - not vm_cloudinit_snippet_exists | default(false)
    - vm_proxmox_delegate_host | length > 0
  block:
    - name: Ensure snippets directory exists on Proxmox host
      ansible.builtin.file:
        path: "{{ vm_proxmox_snippets_mount_path }}/snippets"
        state: directory
        mode: "0755"
      delegate_to: "{{ vm_proxmox_delegate_host }}"

    - name: Write snippet file on Proxmox host
      ansible.builtin.copy:
        content: "{{ vm_cloudinit_user_data_content }}"
        dest: "{{ vm_proxmox_snippets_mount_path }}/snippets/{{ cloudinit_user_data_snippet_filename }}"
        mode: "0644"
      delegate_to: "{{ vm_proxmox_delegate_host }}"
  rescue:
    - name: Warn when inventory snippet fallback failed
      ansible.builtin.debug:
        msg: >-
          Inventory fallback for snippet creation failed on {{ vm_proxmox_delegate_host }}.
          Continuing without cicustom snippet.

- name: Re-query Proxmox storage content after SSH fallback
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/storage/{{ vm_cloudinit_snippet_storage_id }}/content"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 404, 500]
  register: proxmox_snippet_storage_content_after_fallback_response
  failed_when: false
  when:
    - vm_cloudinit_snippet_source | length > 0
    - enable_inventory_snippet_fallback | bool
    - not vm_cloudinit_snippet_exists | default(false)

- name: Resolve pre-created cloud-init snippet usage
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_enabled: >-
      {{
        (vm_cloudinit_snippet_source | length > 0) and
        (
          vm_cloudinit_snippet_exists | default(false)
          or
          (
            (proxmox_snippet_storage_content_after_fallback_response.status | default(500) | int == 200)
            and
            (
              (
                proxmox_snippet_storage_content_after_fallback_response.json.data
                | default([])
                | selectattr('volid', 'equalto', vm_cloudinit_snippet_volid)
                | list
                | length
              ) > 0
            )
          )
        )
      }}
    vm_cloudinit_cicustom_value: "{{ vm_cloudinit_snippet_source }}"

- name: Warn when no proxmox_api inventory host is available for fallback
  ansible.builtin.debug:
    msg: "No host found in group 'proxmox_api'. Skipping inventory snippet fallback."
  when:
    - vm_cloudinit_snippet_source | length > 0
    - enable_inventory_snippet_fallback | bool
    - not vm_cloudinit_snippet_exists | default(false)
    - vm_proxmox_delegate_host | length == 0

- name: Warn when configured/default cicustom snippet does not exist
  ansible.builtin.debug:
    msg: >-
      Cloud-init snippet '{{ vm_cloudinit_snippet_source }}' was not found on storage '{{ vm_cloudinit_snippet_storage_id }}'.
      Continuing without cicustom so VM can start.
  when:
    - vm_cloudinit_snippet_source | length > 0
    - not vm_cloudinit_snippet_enabled

- name: Build optional cicustom payload
  ansible.builtin.set_fact:
    vm_optional_cicustom_payload: >-
      {{
        {'cicustom': vm_cloudinit_cicustom_value}
        if vm_cloudinit_snippet_enabled
        else {}
      }}

- name: Determine effective cloud-init wait behavior
  ansible.builtin.set_fact:
    vm_wait_for_cloudinit: "{{ wait_for_cloudinit | bool }}"

- name: Check if target VM already exists
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 404, 500]
  register: proxmox_existing_vm_config_response
  failed_when: false

- name: Set VM existence flag
  ansible.builtin.set_fact:
    vm_already_exists: "{{ proxmox_existing_vm_config_response.status | int == 200 }}"

- name: Clone Debian 13 template via Proxmox API
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ proxmox_template_vmid }}/clone"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      newid: "{{ vm_vmid }}"
      name: "{{ vm_name }}"
      full: 1
      storage: "{{ vm_storage }}"
      target: "{{ proxmox_node }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  when: not vm_already_exists

- name: Wait until VM config is available after clone
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_ready_response
  until: proxmox_vm_ready_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: not vm_already_exists

- name: Build optional SSH key payload
  ansible.builtin.set_fact:
    vm_optional_sshkeys_payload: "{{ {'sshkeys': cloudinit_ssh_public_keys} if cloudinit_ssh_public_keys | length > 0 else {} }}"

- name: Build common VM config payload
  ansible.builtin.set_fact:
    vm_config_payload_common:
      name: "{{ vm_name }}"
      cpu: "{{ vm_cpu_type }}"
      sockets: "{{ cpu_sockets | int }}"
      cores: "{{ cpu_cores | int }}"
      memory: "{{ memory_mb | int }}"
      onboot: "{{ 1 if vm_onboot else 0 }}"
      agent: "{{ 1 if vm_qemu_agent else 0 }}"
      numa: "{{ 1 if vm_numa else 0 }}"
      hotplug: "{{ vm_hotplug }}"
      ciuser: "{{ vm_effective_ciuser }}"
      ipconfig0: "{{ vm_ipconfig0 }}"
      net0: "virtio,bridge={{ network_bridge }},tag={{ vlan_tag }},firewall={{ 1 if vm_firewall else 0 }},mtu={{ vm_mtu }}"

- name: Configure VM hardware and cloud-init networking (dhcp)
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) | combine(vm_optional_cicustom_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 400, 500]
  register: proxmox_config_dhcp_response
  until: proxmox_config_dhcp_response.status | int in [200, 400]
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: vm_ip_mode == 'dhcp'
  failed_when: false

- name: Disable cicustom after DHCP config 400 failure
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_enabled: false
    vm_optional_cicustom_payload: {}
  when:
    - vm_ip_mode == 'dhcp'
    - proxmox_config_dhcp_response.status | int == 400

- name: Retry DHCP config without cicustom after 400 failure
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_config_dhcp_retry_response
  until: proxmox_config_dhcp_retry_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when:
    - vm_ip_mode == 'dhcp'
    - proxmox_config_dhcp_response.status | int == 400
  failed_when: proxmox_config_dhcp_retry_response.status | int != 200

- name: Validate DHCP config result
  ansible.builtin.assert:
    that:
      - proxmox_config_dhcp_response.status | int == 200 or (proxmox_config_dhcp_retry_response.status | default(0) | int == 200)
    fail_msg: "DHCP VM config failed in Proxmox API."
  when: vm_ip_mode == 'dhcp'

- name: Configure VM hardware and cloud-init networking (static)
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine({'nameserver': static_dns1 + ' ' + static_dns2}) | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) | combine(vm_optional_cicustom_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 400, 500]
  register: proxmox_config_static_response
  until: proxmox_config_static_response.status | int in [200, 400]
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: vm_ip_mode == 'static'
  failed_when: false

- name: Disable cicustom after static config 400 failure
  ansible.builtin.set_fact:
    vm_cloudinit_snippet_enabled: false
    vm_optional_cicustom_payload: {}
  when:
    - vm_ip_mode == 'static'
    - proxmox_config_static_response.status | int == 400

- name: Retry static config without cicustom after 400 failure
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body: "{{ vm_config_payload_common | combine({'nameserver': static_dns1 + ' ' + static_dns2}) | combine(vm_optional_sshkeys_payload) | combine(vm_optional_password_payload) }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_config_static_retry_response
  until: proxmox_config_static_retry_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when:
    - vm_ip_mode == 'static'
    - proxmox_config_static_response.status | int == 400
  failed_when: proxmox_config_static_retry_response.status | int != 200

- name: Validate static config result
  ansible.builtin.assert:
    that:
      - proxmox_config_static_response.status | int == 200 or (proxmox_config_static_retry_response.status | default(0) | int == 200)
    fail_msg: "Static VM config failed in Proxmox API."
  when: vm_ip_mode == 'static'

- name: Read current VM config
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_config_response

- name: Extract current disk config
  ansible.builtin.set_fact:
    vm_scsi0_config: "{{ proxmox_vm_config_response.json.data.scsi0 | default('') }}"
    vm_current_disk_gb: "{{ ((proxmox_vm_config_response.json.data.scsi0 | default('') | regex_findall('size=(\\d+)G') | first | default('0')) | int) }}"
    vm_has_serial0: "{{ proxmox_vm_config_response.json.data.serial0 is defined }}"

- name: Set graphic card to default and remove serial0 when present
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      vga: "{{ vm_vga }}"
      delete: "serial0"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_display_with_delete_response
  until: proxmox_display_with_delete_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: vm_has_serial0 | bool
  failed_when: proxmox_display_with_delete_response.status | int != 200

- name: Set graphic card to default when serial0 is not present
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      vga: "{{ vm_vga }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_display_only_response
  until: proxmox_display_only_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: not vm_has_serial0 | bool
  failed_when: proxmox_display_only_response.status | int != 200

- name: Validate disk config exists
  ansible.builtin.assert:
    that:
      - vm_scsi0_config | length > 0
    fail_msg: "Could not read scsi0 from VM config. Ensure Debian template disk is on scsi0."

- name: Fail if requested disk is smaller than template disk
  ansible.builtin.assert:
    that:
      - disk_size_gb | int >= vm_current_disk_gb | int
    fail_msg: "Requested disk_size_gb ({{ disk_size_gb }}) is smaller than template disk ({{ vm_current_disk_gb }}G). Proxmox cannot shrink disk via API."

- name: Expand disk when requested size is larger than current size
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/resize"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      disk: scsi0
      size: "+{{ (disk_size_gb | int) - (vm_current_disk_gb | int) }}G"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_resize_response
  until: proxmox_resize_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: disk_size_gb | int > vm_current_disk_gb | int
  failed_when: proxmox_resize_response.status | int != 200

- name: Build scsi0 config with backup disabled
  ansible.builtin.set_fact:
    vm_scsi0_with_backup_disabled: >-
      {{
        vm_scsi0_config | regex_replace('backup=1', 'backup=0')
        if 'backup=' in vm_scsi0_config
        else vm_scsi0_config + ',backup=0'
      }}

- name: Apply backup disabled on scsi0
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/config"
    method: PUT
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      scsi0: "{{ vm_scsi0_with_backup_disabled }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_backup_flag_response
  until: proxmox_backup_flag_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  failed_when: proxmox_backup_flag_response.status | int != 200

- name: Read current VM runtime status
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/status/current"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_vm_status_response

- name: Ensure VM is started
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/status/start"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_start_response
  until: proxmox_start_response.status | int == 200
  retries: "{{ proxmox_operation_retries }}"
  delay: "{{ proxmox_operation_delay }}"
  when: (proxmox_vm_status_response.json.data.status | default('stopped')) != 'running'
  failed_when: proxmox_start_response.status | int != 200

- name: Wait for QEMU guest agent to become ready
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/ping"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_agent_ping_response
  until: proxmox_agent_ping_response.status | int == 200
  retries: "{{ cloudinit_wait_retries }}"
  delay: "{{ cloudinit_wait_delay }}"
  when: (vm_wait_for_cloudinit | bool) or (join_ad | bool)
  failed_when: false

- name: Determine guest-agent readiness
  ansible.builtin.set_fact:
    vm_guest_agent_ready: "{{ (proxmox_agent_ping_response.status | default(500) | int) == 200 }}"
  when: (vm_wait_for_cloudinit | bool) or (join_ad | bool)

- name: Warn when guest-agent is not available for cloud-init wait
  ansible.builtin.debug:
    msg: "QEMU guest agent is not reachable; skipping cloud-init wait checks."
  when:
    - vm_wait_for_cloudinit | bool
    - not vm_guest_agent_ready | default(false)

- name: Require guest-agent for AD join
  ansible.builtin.assert:
    that:
      - vm_guest_agent_ready | default(false)
    fail_msg: "join_ad=true requires QEMU guest agent to be reachable in the VM."
  when: join_ad | bool

- name: Start cloud-init wait command inside guest
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/exec"
    method: POST
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    body_format: form-urlencoded
    body:
      command:
        - cloud-init
        - status
        - --wait
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: 200
  register: proxmox_cloudinit_exec_response
  when:
    - vm_wait_for_cloudinit | bool
    - vm_guest_agent_ready | default(false)

- name: Poll cloud-init wait command result
  ansible.builtin.uri:
    url: "https://{{ proxmox_api_host }}:8006/api2/json/nodes/{{ proxmox_node }}/qemu/{{ vm_vmid }}/agent/exec-status?pid={{ proxmox_cloudinit_exec_response.json.data.pid }}"
    method: GET
    headers:
      Authorization: "{{ proxmox_auth_header }}"
    validate_certs: "{{ proxmox_validate_certs }}"
    return_content: true
    status_code: [200, 500]
  register: proxmox_cloudinit_exec_status_response
  until:
    - proxmox_cloudinit_exec_status_response.status | int == 200
    - (proxmox_cloudinit_exec_status_response.json.data.exited | default(false) | bool)
    - (proxmox_cloudinit_exec_status_response.json.data.exitcode | default(1) | int) == 0
  retries: "{{ cloudinit_wait_retries }}"
  delay: "{{ cloudinit_wait_delay }}"
  when:
    - vm_wait_for_cloudinit | bool
    - vm_guest_agent_ready | default(false)
  failed_when: >
    proxmox_cloudinit_exec_status_response.status | int != 200 or
    not (proxmox_cloudinit_exec_status_response.json.data.exited | default(false) | bool) or
    (proxmox_cloudinit_exec_status_response.json.data.exitcode | default(1) | int) != 0

- name: Ensure root password is applied inside guest
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Apply root password"
    guest_exec_no_log: true
    guest_exec_command: >-
      PW=$(printf '%s' '{{ root_password | b64encode }}' | base64 -d);
      echo "root:${PW}" | chpasswd;
      passwd -u root >/dev/null 2>&1 || true
  when:
    - root_password | length > 0
    - vm_guest_agent_ready | default(false)

- name: AD join - install required packages
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Install AD packages"
    guest_exec_retries: 360
    guest_exec_delay: 5
    guest_exec_command: >-
      export DEBIAN_FRONTEND=noninteractive &&
      apt-get update &&
      apt-get install -y realmd sssd sssd-tools libnss-sss libpam-sss adcli samba-common-bin oddjob oddjob-mkhomedir packagekit sudo ntpsec dnsutils
  when: join_ad | bool

- name: AD join - configure NTP server
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Configure NTP"
    guest_exec_allow_missing_pid: true
    guest_exec_command: >-
      sed -i '/^pool /d' /etc/ntpsec/ntp.conf;
      sed -i '/^server /d' /etc/ntpsec/ntp.conf;
      echo "server {{ ad_ntp_server_ip | trim }} prefer" >> /etc/ntpsec/ntp.conf;
      systemctl restart ntpsec.service
  when:
    - join_ad | bool
    - ad_ntp_server_ip | trim | length > 0

- name: AD join - verify NTP service and config
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Verify NTP config"
    guest_exec_allow_missing_pid: true
    guest_exec_command: >-
      grep -Eq '^server[[:space:]]+{{ ad_ntp_server_ip | trim }}([[:space:]]|$)' /etc/ntpsec/ntp.conf &&
      systemctl is-active --quiet ntpsec
  when:
    - join_ad | bool
    - ad_ntp_server_ip | trim | length > 0

- name: AD join - keep default NTP servers when no AD NTP IP is provided
  ansible.builtin.debug:
    msg: "ad_ntp_server_ip is empty. Keeping Debian default NTP configuration."
  when:
    - join_ad | bool
    - ad_ntp_server_ip | trim | length == 0

- name: AD join - join domain
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Join Active Directory domain"
    guest_exec_retries: 180
    guest_exec_delay: 5
    guest_exec_allow_missing_pid: true
    guest_exec_command: >-
      if realm list -a | grep -iq '^domain-name:\s*{{ ad_domain_name | lower }}$'; then
        exit 0;
      fi;
      printf '%s' '{{ ad_join_password | b64encode }}' | base64 -d | realm join -U '{{ ad_join_user }}' '{{ ad_domain_name }}'
    guest_exec_no_log: true
  when: join_ad | bool

- name: AD join - verify realm membership
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Verify Active Directory domain join"
    guest_exec_command: >-
      realm list -a | grep -iq '^domain-name:\s*{{ ad_domain_name | lower }}$'
  when: join_ad | bool

- name: AD join - enable mkhomedir in PAM
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Configure PAM mkhomedir"
    guest_exec_command: >-
      LINE='session optional        pam_mkhomedir.so skel=/etc/skel umask=077';
      grep -qF "$LINE" /etc/pam.d/common-session || echo "$LINE" >> /etc/pam.d/common-session
  when: join_ad | bool

- name: AD join - configure SSSD and restart service
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Configure SSSD"
    guest_exec_command: >-
      if [ ! -s /etc/sssd/sssd.conf ]; then
        echo "/etc/sssd/sssd.conf is missing or empty" >&2; exit 1;
      fi;
      if ! grep -q '^\[domain/' /etc/sssd/sssd.conf; then
        echo "/etc/sssd/sssd.conf has no [domain/*] section" >&2; exit 1;
      fi;
      if grep -Eq '^[[:space:]]*use_fully_qualified_names[[:space:]]*=' /etc/sssd/sssd.conf; then
        sed -i 's/^[[:space:]]*use_fully_qualified_names[[:space:]]*=.*/use_fully_qualified_names = False/' /etc/sssd/sssd.conf;
      else
        awk '{
          print;
          if (!done && $0 ~ /^\[domain\/.*\]$/) {
            print "use_fully_qualified_names = False";
            done=1;
          }
        }' /etc/sssd/sssd.conf > /tmp/sssd.conf.new &&
        mv /tmp/sssd.conf.new /etc/sssd/sssd.conf;
      fi;
      chmod 600 /etc/sssd/sssd.conf;
      systemctl restart sssd
  when: join_ad | bool

- name: AD join - verify SSSD service is active
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Verify SSSD service"
    guest_exec_command: "systemctl is-active --quiet sssd"
  when: join_ad | bool

- name: AD join - configure sudo group
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Configure AD sudo group"
    guest_exec_command: >-
      HOSTNAME_SHORT=$(hostname -s);
      SUDO_GROUP="SYS-${HOSTNAME_SHORT}-SUDO@{{ ad_domain_name }}";
      echo "%${SUDO_GROUP} ALL=(ALL) ALL" > /etc/sudoers.d/ad-sudo;
      chmod 440 /etc/sudoers.d/ad-sudo
  when: join_ad | bool

- name: AD join - configure SSH permitted group
  ansible.builtin.include_tasks: guest_exec.yml
  vars:
    guest_exec_name: "Configure AD SSH group"
    guest_exec_command: >-
      HOSTNAME_SHORT=$(hostname -s);
      SSH_GROUP="SYS-${HOSTNAME_SHORT}-SSH@{{ ad_domain_name }}";
      realm permit -g "${SSH_GROUP}"
  when: join_ad | bool

- name: Output summary
  ansible.builtin.debug:
    msg:
      - "VM created: {{ vm_name }} (vmid={{ vm_vmid }})"
      - "Disk: {{ disk_size_gb }}G, CPU: {{ cpu_sockets }} sockets x {{ cpu_cores }} cores, RAM: {{ memory_mb }} MB"
      - "Network: bridge={{ network_bridge }}, vlan={{ vlan_tag }}, mode={{ vm_ip_mode }}"
      - "Cloud-init login user: {{ vm_effective_ciuser }}"
      - "Cloud-init initialization: {{ 'waited until done' if (vm_wait_for_cloudinit | bool and vm_guest_agent_ready | default(false)) else 'wait skipped/disabled' }}"
      - "Cloud-init custom snippet: {{ vm_cloudinit_cicustom_value if vm_cloudinit_snippet_enabled else 'not set' }}"
      - "AD join: {{ 'completed for ' + ad_domain_name if join_ad | bool else 'disabled' }}"
